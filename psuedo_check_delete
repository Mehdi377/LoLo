//psuedo code for check()

define a global array "targetcells" to identify the cells to be deleted. implementation can be done in multiple ways , so i leave it to you.
//following is a simple implementation of targetcells( as an array)
int targetcells[25]={0};   //board[x][y] corresponds to targetcells[x*5+y],
                           // 0 represents not a positive find
                           // 1 represents positive find

check(int x, int y)  
{
   targetcells[x*5+y]=1;  //add board[x][y]'s index in the targetcells   
   
   -iterate through the four adjacent cells,
    for(i=-1;i<2;i+2)
                - check for boundary condition      // if board[x+i][y] exists
                if the boudary condition fails, continue;
          - check if board[x][y]=board[x+i][y] 
               -if true, 
                      (targetcells[(x+i)*5+y]!=1)  //  check if the cell is already check()ed ,ie check in targetcells.
                 ie,                   
                     if false check(x+i,y);  //fyi , recursion occurs here
           - do the same for board[x][y+i]       
                  ....

} // after the execution you can check the targetcells(search for 1s) to get the indice(s) of the cells to be deleted.




//psuedo code for deletion

delete(int x, int y, int num)    //(x,y) is the input cell  index and num is the number you want in it after deletion
{
    iterate through the board  // lets say with indices i,j
      if the index is present in targetcells,
            board[i][i]=-1;
            and remove the entry from targetcells
            
    board[x][y]=num; // you dont want to  delete the selected cell ;)
    
    iterate thourgh the board, bottom to top ,each column at a time
    for(i=4;i>0;i--)
       for(j=4;j>0;j--)
        if board[i][j]==-1
            board[i][j]=board[i-1][j]
            board[i-1][j]=-1;
 }       // after executing this function board[][] might have empty cells(-1) at the top. 
         //check for -1 and fill them with random numbers, using another function.
